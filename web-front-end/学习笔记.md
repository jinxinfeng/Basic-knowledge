## JavaScript核心知识点

### 1、深刻理解JavaScript里面的面向对象

```javascript
//我们只需要关注对象的行为，而不需要去关注对象本身
let dog = {
    dogSaying: () => {
        console.log('汪汪汪')
    }
};
let cat = {
    dogSaying: () => {	
        console.log('汪汪汪')
    }
}
let family = [];

let joinFamily = animal => {
    if(animal && typeof animal.dogSaying === 'function'){
        family.push(animal);
        console.log('欢迎加入汪星人家庭')
        console.log(`汪星人家庭已经有 ${family.length}成员`)
    }
}
joinFamily(dog);
joinFamily(cat);

//如果一种方法和功能应用到不同的对象身上这样就形成了多态
let Dog = function () {}
Dog.prototype.sound = function() {
    console.log('汪汪汪')
}
let Cat = function () {}
Cat.prototype.sound = function () {
    console.log('喵喵喵')
}
let addSound = function(animal){
    animal.sound();
};
addSound(new Dog())
addSound(new Cat())


```



## ES6核心知识点

### 1、es6新特性浏览器支持情况

| 浏览器  | 最低版本支持 |
| :-----: | :----------: |
| chrome  |      49      |
| Firefox |      58      |
|   IE    |      11      |
|  Edge   |      16      |

### 2、解决浏览器兼容使用babel（es6->es5）

#### 2.1 配置babel环境

```shell
npm init -y
npm install -D babel-core babel-preset-es2015 babel-preset-latest
#创建.babelrc并编写如下
{
    "presets": ["es2015", "latest"],
    "plugins": []
}
npm install -g babel-cli
babel -V
#创建一个新特性语法，并且编译
let ans = [11,22,33];
console.log(ans.reduce((a1,a2)=>a1+a2,0))
#编译之后
(base) C:\Users\jesse\Desktop\1月\basic-knowledge\web-front-end\es6>babel ./src/index.js
Debugger attached.
"use strict";

var ans = [11, 22, 33];
console.log(ans.reduce(function (a1, a2) {
  return a1 + a2;
}, 0));
```

### 3、es6里面的变量	

```javascript
//let和const不能重复声明
  let a=6;
  let a=9;
  alert(a);
  // redeclaration of let a
  const b=1;
  const b=6;
  alert(b);
  // redeclaration of const b 
//const不能修改
  const c=1;
  c=2;
  alert(c);
//invalid assignment to const 'c'
		//声明块级作用域
	 	//es5里面的var的问题
        //内部的变量覆盖外部的变量
        var t = Math.random();
        alert(t);
        function fn(){
            alert(t); //undefined
           
            var t='new value'
            alert(t)//new value
        }
        fn()
  		//es5里面的var的问题
        //内部的变量覆盖外部的变量
        var t = Math.random();
        alert(t);
        function fn(){
            alert(t); //undefined
           
            var t='new value'

            alert(t)//new value
            t='new value1'
            alert(t)//new value1
        }
        fn()
		//一个经典问题
        window.onload=function(){
            var oBtn=document.getElementsByTagName('input')
            for(var i=0;i<oBtn.length;i++){
                oBtn[i].onclick=function(){
                    alert(i) //全是弹出3,var声明时,i是一个全局变量,当i跳出循环只能是3
                }
            }
        }
        window.onload=function(){
            var oBtn=document.getElementsByTagName('input')
            for(let i=0;i<oBtn.length;i++){
                oBtn[i].onclick=function(){
                    alert(i) //全是弹出0 1 2,let声明时,i是一个局部变量,当i在for的块级作用域里面有三个局部变量
                }
            }
        }
        //闭包解决
        window.onload = function () {
            var oBtn = document.getElementsByTagName('input')
            for (var i = 0; i < oBtn.length; i++) {
                oBtn[i].onclick = (function (i) {
                    return function () {
                        console.log(i)
                    }
                })(i)
            }
        }
	//html代码
    <input type="button" value="1">
    <input type="button" value="2">
    <input type="button" value="3">
     
```

### 4、解构赋值

```javascript
//访问一个对象,es5访问值
let json={a:1,b:2,c:3}
// let a=json.a;
// let b=json.b;
// let c=json.c;
// console.log(a,b,c);
//es6
let {a,b,c}=json;
console.log(a,b,c);
//嵌套解构
let stu = {
    id:00,
    addr:'sx',
    other:{
        people:400,
        pos:{
            x:1
        }
    }
}
let {other:{pos}}=stu;
console.log(pos.x)//1
//默认值
let animal={
    type:'dog',
    nums:444,
}
let {type,nums,flag=true}=animal
console.log(type,nums,flag)//指定flag为默认true
//注意右边一定要有解构的东西
```

### 5、箭头函数

```javascript
//作用:简化代码结构
let a=function(i){
    return Math.pow(i,2);
}
console.log(a(8))//64
//改写
let b=i=>{return Math.pow(i,2)};
console.log(b(7))//49
//参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math
let c=(i,j)=>{
    return Math.imul(i,j);//返回乘法结果
}
console.log(c(2,5));//10
//让回调函数看起来更加简单
let ans=[11,22,33];
let d=ans.reduce(((i,j)=>i+j),0);
console.log(d);//66
//改变this指向
//改变this指向,一个常见的例子
let book={
    tags:['a','b'],
    name:'summer',
    whichTags:function(){
        return this.tags.map(function(item){
            return `${item}属于${this.name}的标签`;
        })
    }

}
console.log(book.whichTags());//[ 'a属于undefined的标签', 'b属于undefined的标签' ]
//用变量self修改
let book={
    tags:['a','b'],
    name:'summer',
    whichTags:function(){
        let self=this;
        console.log(self)
        console.log(this)
        return this.tags.map(function(item){
           // console.log(this) [Function (anonymous)]
            return `${item}属于${self.name}的标签`;
        })
    }

}
console.log(book.whichTags());//[ 'a属于summer的标签', 'b属于summer的标签' ]
//使用bind,修改指向为this
let book={
    tags:['a','b'],
    name:'summer',
    whichTags:function(){
        return this.tags.map(function(item){
           // console.log(this) [Function (anonymous)]
            return `${item}属于${this.name}的标签`;
        }.bind(this))
    }

}
console.log(book.whichTags());//[ 'a属于summer的标签', 'b属于summer的标签' ]
// 使用箭头函数
let book={
    tags:['a','b'],
    name:'summer',
    whichTags:function(){
        return this.tags.map(item=>{
            return `${item}属于${this.name}的标签`;
            //箭头函数this表示定义(定义这个book)时候的this，而不是当前函数（箭头函数）使用时候的this
        })
    }

}
console.log(book.whichTags());//[ 'a属于summer的标签', 'b属于summer的标签' ]
//注意点:
//箭头函数不能够构造函数使用，也就是不能new 箭头函数没有arguments参数对象 不能使用Generator 函数 箭头函数的this表示的是定义时的那个this，不是当前使用的this

```

### 6、rest参数、模板字符串、展开运算符

```javascript
//rest参数,代替那个arguments
//计算3个数字之和
function addSum(a,b,c){
    var nums=[a,b,c];
    return nums.reduce((sum,num)=>{
        return sum+num;
    },0);
}
console.log(addSum(1,2,3))//6
//rest参数代替
let addSum2=(...nums)=>{
    return nums.reduce((sum,num)=>{
        return sum+num;
    },0);
}
console.log(addSum2(1,2,3,4))//10
//在解构赋值里面使用rest参数,必须最后一个，不能在setter函数之中使用
let [a,b,c,...nums]=[3,4,5,3.4,5,{s:2,c:3}]
console.log(nums)//[ 3.4, 5, { s: 2, c: 3 } ]
//模板字符串 ``进行标识 可以多行 用${}进行加入变量和函数进行识别,多用就好了
let sum=(i,j)=>{
    return i+j;
}
console.log(`这个函数的结果是${sum(1,3)}`)//这个函数的结果是4
let str=`hello world`
console.log(`看看这个结果${str}`)// 看看这个结果hello world
//拓展运算符，和rest参数类似,rest参数像是用...a来表示一个数组,并在后续算法里面使用这个数组,拓展运算表示对这个数组用...a来参与运算。
//也很容易实现字符串拼接
let arr=[33,44,55]
console.log(...arr)

```

